# Hashing Complexities with Python

In Python, hashability refers to the ability of an object to have a unique, unchangeable identifier (called a hash value) that is used to store and retrieve the object in data structures like dictionaries and sets. A hashable element is an object that has a hash value that remains the same throughout its lifetime. Immutable objects like numbers, strings, and tuples with immutable elements are hashable, while mutable objects like lists, sets, and dictionaries are not hashable.

### Hash value?
In Python, a hash value is a unique numerical representation of an object. This hash value is generated by applying a hash function to the object's contents. The hash function is designed to be fast and generate unique values for distinct objects.

Hash values are used for many purposes, such as indexing in dictionaries and sets. For an object to be stored in a set, it must be hashable, meaning it has a unique hash value that remains constant throughout its lifetime. Immutable objects in Python are hashable because their contents cannot be changed. For example, integers, strings, and tuples are hashable objects, while lists and dictionaries are not.

A hashable object is required to have the following properties:

The object must have a `__hash__()` method that computes its hash value.
The object must have an `__eq__()` method to compare it with other objects for equality.
The hash value of the object must remain constant for its entire lifetime (i.e., it must be immutable).

Here's an example:
```python
# Integers
print(hash(5))  # Output: 5
print(hash(-10))  # Output: -10

# Strings
print(hash('hello'))  # Output: 1102266484338832754
print(hash('world'))  # Output: -3810408550115311615

# Tuples
print(hash((1, 2, 3)))  # Output: 529344067295497451
print(hash(('apple', 'banana', 'cherry')))  # Output: 8600900286906204064
```
## Details on Python data structures and their hashability

### Tuples
Tuples are hashable only if all their elements are hashable. Since tuples are immutable, their hash value remains constant throughout their lifetime, making them suitable for use as keys in dictionaries or elements in sets.

```python
t = (1, 2, 3)
print(hash(t))  # This works because all elements in the tuple are hashable (integers).

t = (1, 2, [3, 4])
print(hash(t))  # This raises a TypeError because lists are not hashable.
```

#

### Lists
Lists are not hashable because they are mutable, meaning their contents can change during their lifetime. This makes it impossible to guarantee a constant hash value for lists.

```python
l = [1, 2, 3]
print(hash(l))  # This raises a TypeError because lists are not hashable.
```

#

### Sets
Sets themselves are not hashable, but their elements must be hashable. In other words, we cannot use a set as an element of another set or as a key in a dictionary. However, when we create a set, all of its elements must be hashable (i.e., they must be immutable and have a constant hash value throughout their lifetime).

```python
s = {1, 2, 3}
print(hash(s))  # This raises a TypeError because sets are not hashable. However, the elements inside s are hashable.

```

Let's look at a more complex example.

```python
mercury = {True, "Mercury", [0,1,2]}
mercury

'''
Result:
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [106], in <cell line: 1>()
----> 1 mercury = {True, "Mercury", [0,1,2]}
      2 mercury

TypeError: unhashable type: 'list'
'''
```
This doesn't work because sets only allow for hashable elements, and lists are not hashable in Python. Hashable objects are immutable, and their hash value doesn't change during their lifetime. Since lists are mutable, their hash value can change, and therefore they are not hashable.

To create a set with the above elements, we could use a tuple instead of a list, since tuples are immutable and hashable. We could do something like:
```python
mercury = {True, "Mercury", (0, 1, 2)}
```

#### `frozensets` in the context of Sets
Python provides a special immutable version called `frozenset` that is hashable.

```python
s = frozenset([1, 2, 3])
print(s)  # This works because frozensets are hashable.
```
Output:
```python
frozenset({1, 2, 3})
```

Let's use the mercury example again, this time for a `frozenset`.
```python
mercury = {True, "Mercury", (0, 1, 2)} # List [0, 1, 2] replaced with a tuple (0, 1, 2)
frozen_mercury = frozenset(mercury)
print(frozen_mercury)
```
Output:
```python
frozenset({(0, 1, 2), True, 'Mercury'})
```

#

### Dictionaries
Dictionaries are not hashable since they are mutable, but there are some sophistications similar to that of sets. Dictionaries follow "keys only" concept in the context of hashability, i.e., only the keys of a dictionary need to be hashable. The values in a dictionary do not have to be hashable.

In more details, since dictionary in Python is a collection of key-value pairs, the keys are used to look up the associated values in the dictionary. To enable fast look-up times, dictionaries use hash tables to store and retrieve the key-value pairs. For the hash table to work efficiently, it requires the keys to have a constant hash value throughout their lifetime. **This means that the keys must be immutable and hashable. However, there is no such constraint on the values in a dictionary; they can be of any type, mutable or immutable, hashable or non-hashable**.

Here's an example to illustrate this:
```python
my_dict = {
    "name": "John",          # The key is a hashable string, and the value is a hashable string.
    "age": 30,               # The key is a hashable string, and the value is a hashable integer.
    "hobbies": ["music", "sports"]  # The key is a hashable string, but the value is a non-hashable list.
}
```
In this example, all the keys in `my_dict` are hashable (since they are strings), while the values can be hashable strings, hashable integers, or non-hashable lists.

#### `frozensets` in the context of Dictionaries
We can create hashable dictionaries by converting them to `frozensets` of key-value pairs (as long as both the keys and the values are hashable).

```python
d = {'a': 1, 'b': 2, 'c': 3}
print(hash(d))  # This raises a TypeError because dictionaries are not hashable.

d = frozenset(d.items())
print(hash(d))  # This works because the frozenset is hashable.
```

#

### Strings
Strings are hashable and immutable, so they can be used as keys in dictionaries or elements in sets.

```python
s = "hello"
print(hash(s))  # This works because strings are hashable.
```

#

### Integers, Floats, and Booleans
These basic data types are all hashable and immutable.

```python
i = 42
print(hash(i))  # This works because integers are hashable.

f = 3.14
print(hash(f))  # This works because floats are hashable.

b = True
print(hash(b))  # This works because booleans are hashable.
```
